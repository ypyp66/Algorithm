from collections import deque

graph = [
    # 총 9줄
    # 각 줄은 노드의 번호
    # 내용은 노드에 인접한 노드 목록
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

#각 노드가 방문된 정보를 리스트 자료형으로 표현
visited = [False] * 9

def bfs(graph, start, visited):
    queue = deque([start]) # start노드에서 시작
    visited[start] = True
    
    while queue: # 큐가 빌 때까지 반복
        v = queue.popleft() #먼저온게 왼쪽에 있으므로 왼쪽부터 꺼낸다
        print(v, end=" ")
        
        for i in graph[v]: #해당 노드를 탐색
            if not visited[i]:
                queue.append(i)
                visited[i] = True

bfs(graph, 1, visited)

'''
1번 노드 -> 1번 큐에서 제거 및 방문처리, 인접한 노드인 2,3,8을 queue에 넣음 (2,3,8)         => 1
2번 노드 -> 2번 큐에서 제거 및 방문처리, 방문하지 않은 7번 노드를 queue에 넣음 (3,8,7)       => 2
3번 노드 -> 3번 큐에서 제거 및 방문처리, 방문하지 않은 4,5번 노드를 queue에 넣음 (8,7,4,5)   => 3
8번 노드 -> 8번 큐에서 제거 및 방문처리, 방문하지 않은 노드가 없으므로 pass (7,4,5)          => 8
7번 노드 -> 7번 큐에서 제거 및 방문처리, 방문하지 않은 6번 노드를 queue에 넣음 (4,5,6)       => 7
4번 노드 -> 4번 큐에서 제거 및 방문처리, 방문하지 않은 노드가 없으므로 pass (5,6)            => 4
5번 노드 -> 5번 큐에서 제거 및 방문처리, 방문하지 않은 노드가 없으므로 pass (6)              => 5
6번 노드 -> 6번 큐에서 제거 및 방문처리, 방문하지 않은 노드가 없으므로 pass ()               => 6

### bfs는 인접 노드가 방문하지 않은 노드이면 .append를 하고 방문한 노드이면 pass한다.
### 큐와 큐 자료구조를 이용한다
'''